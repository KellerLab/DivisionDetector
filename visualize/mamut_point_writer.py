from __future__ import print_function
import json
import os
import sys
import mamut_xml_templates as mamut_temp


class MamutPointWriter:
    def __init__(self):
        self.point_time_dict = {}
        self.point_num = 0
        self.tracks = []

        self.extra_time_start = None
        self.extra_point_start = None
        self.extra_point_end = None

    def add_points_from_json(self, json_filename, time, group, ani=None):
        """ Reads a json file of the format generated by create_test_benchmark.py into point_time_dict

            :param json_filename: the name of the json file
            :param time: the time frame that the json contains points in (not supporting json files with multiple times)
            :param group: a number indicating the group in which to put these points. Each group will have its own color
            :param ani: how much to multiply each coordinate by to match the raw data
            """
        if not ani:
            ani = [1, 1, 1]

        with open(json_filename) as json_data:
            d = json.load(json_data)
        points = d['divisions']

        if time not in self.point_time_dict:
            self.point_time_dict[time] = []

        if type(points) == dict:
            points = [cell_dict for _, cell_dict in points.items()]

        for cell_dict in points:
            point = [self.point_num, group]
            coords = cell_dict['center']
            for i in range(3):
                coords[i] = coords[i]*ani[i]
            point.extend(coords)
            assert (len(point) == 5)
            self.point_time_dict[time].append(point)
            self.point_num += 1

    def add_points_from_txt(self, text_filename, group, time=None, ani=None):
        """ Reads a text file with one point per line into the point_time_dict

        :param text_filename: one point per line, either in format t,z,y,x if time=None, or z,y,x if time is specifiied
        :param group: a number indicating the group in which to put these points. Each group will have it's own color.
        :param time: if not None, specifies the time frame for all points in file
        :param ani: how much to multiply each coordiante by to match the raw data
        """
        if not ani:
            ani = [1, 1, 1]

        with open(text_filename, 'r') as gt:
            for line in gt.readlines():
                info = line.split()
                point_time = time
                if time:
                    assert(len(info) == 3)
                    coords = info
                else:
                    assert(len(info) == 4)
                    coords = info[1:]
                    point_time = int(info[0])

                for i in range(3):
                    coords[i] = coords[i] * ani[i]
                point = [self.point_num, group]
                point.extend(coords)
                assert (len(point) == 5)

                if point_time not in self.point_time_dict:
                    self.point_time_dict[point_time] = []
                self.point_time_dict[point_time].append(point)
                self.point_num += 1

    def write_to_file(self, bdv_file, outfile):
        """ Writes the points that have been loaded into the MaMuTPointWriter object to file

        :param bdv_file: the path to the raw data (might only work if in the same directory and prefaced with './'
        :param outfile: the file where the data should be written (should end in .xml)
        """
        if self.point_num == 0:
            print("Error: no points to plot")
            return

        if not os.path.exists(os.path.dirname(outfile)):
            os.makedirs(os.path.dirname(outfile))

        # Make a single artificial spot in consecutive frame so that MaMuT doesn't complain about tracks being null
        self.extra_time_start = int(list(self.point_time_dict.keys())[0])
        self.extra_point_start = self.point_time_dict[self.extra_time_start][0]
        self.extra_point_end = self.__copy_point_to_next_frame(self.extra_time_start, self.extra_point_start)

        with open(outfile, 'w') as output:
            output.write(mamut_temp.begin_template)

            # Begin AllSpots.
            output.write(mamut_temp.allspots_template.format(nspots=self.point_num))

            for time in self.point_time_dict.keys():

                # Begin SpotsInFrame
                output.write(mamut_temp.inframe_template.format(frame=time))
                points = self.point_time_dict[time]
                for point in points:
                    self.__write_annotation(output, time, point)

                # End SpotsInFrame
                output.write(mamut_temp.inframe_end_template)

            # End AllSpots.
            output.write(mamut_temp.allspots_end_template)

            # Begin AllTracks.
            output.write(mamut_temp.alltracks_template)

            # Make a single artificial track with a single edge so that MaMuT doesn't complain about null tracks
            output.write(mamut_temp.track_template.format(id=1, duration=2,
                                                          start=self.extra_time_start,
                                                          stop=self.extra_time_start + 1,
                                                          nspots=2,
                                                          displacement=0))
            output.write(mamut_temp.edge_template.format(source_id=self.extra_point_start[0],
                                                         target_id=self.extra_point_end[0],
                                                         velocity=0,
                                                         displacement=0,
                                                         t_id=0,
                                                         time=self.extra_time_start))
            output.write(mamut_temp.track_end_template)

            # End AllTracks.
            output.write(mamut_temp.alltracks_end_template)

            # Filtered tracks (also just to avoid null error).
            output.write(mamut_temp.filteredtracks_start_template)
            output.write(mamut_temp.filteredtracks_template.format(t_id=1))
            output.write(mamut_temp.filteredtracks_end_template)

            # End XML file.
            filename = os.path.basename(bdv_file)
            folder = os.path.dirname(bdv_file)
            output.write(mamut_temp.end_template.format(
                image_data=mamut_temp.im_data_template.format(filename=filename, folder=folder)))

    @staticmethod
    def __write_annotation(output, time, point):
        """ Writes an annotation point to xml

        :param output: file to write to
        :param time: the time frame the point is in
        :param point: [id, group, z, y, x]
        """
        group = point[1]
        name = "DIV_" + str(group)
        output.write(mamut_temp.spot_template.format(id=int(point[0]),
                                                     name=name,
                                                     frame=time,
                                                     x=float(point[4]),
                                                     y=float(point[3]),
                                                     z=float(point[2]),
                                                     quality=group))

    def __copy_point_to_next_frame(self, time, point):
        """ Used to create an artificial track to placate MaMuT
        (It won't draw anything if there are no tracks at all)

        :param time: the time frame of the original point
        :param point: the point to copy
        :return: the new copy of the point (same but with new id)
        """
        time_end = time + 1
        point_copy = list(point)

        point_copy[0] = self.point_num
        if time_end not in self.point_time_dict:
            self.point_time_dict[time_end] = []
        self.point_time_dict[time_end].append(point_copy)
        self.point_num += 1
        return point_copy


if __name__ == '__main__':
    if len(sys.argv) < 4:
        print("Usage: python mamut_point_writer.py <raw_data> <outfile> <infile1,time1> ...")
        exit(1)

    raw_data = sys.argv[1]
    outfile = sys.argv[2]
    infiles = sys.argv[3:]

    writer = MamutPointWriter()
    group = 0
    for file_and_time in infiles:
        spl = file_and_time.split(",")
        file = spl[0]
        time = None
        if len(spl) > 1:
            time = int(spl[1])
        else:
            print("each infile argument must include either 1 or 0 commas")
            exit(1)

        if file.endswith(".json"):
            writer.add_points_from_json(file, time, group)
        elif file.endswith(".txt") or file.endswith(".csv"):
            writer.add_points_from_txt(file, group, time=time)

    writer.write_to_file(raw_data, outfile)
